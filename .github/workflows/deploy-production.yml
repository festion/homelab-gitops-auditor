name: Deploy to Production

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
        - production
        - hotfix

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  pre-deployment-checks:
    name: Pre-deployment Validation
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'
        
    - name: Install dependencies (API)
      run: |
        cd api
        npm ci
        
    - name: Install dependencies (Dashboard)
      run: |
        cd dashboard
        npm ci
        
    - name: Run complete test suite
      run: |
        # Unit tests
        cd api && (npm run test:unit || npm test)
        cd ../dashboard && (npm run test:unit || npm test)
        
        # Integration tests
        cd ../api && (npm run test:integration || echo "Integration tests not configured")
        cd ../dashboard && (npm run test:integration || echo "Integration tests not configured")
        
        # E2E tests
        cd .. && (npm run test:e2e || echo "E2E tests not configured")
        
        # Security tests
        cd api && (npm run test:security || echo "Security tests not configured")
        cd ../dashboard && (npm run test:security || echo "Security tests not configured")
        
        # Performance tests
        cd .. && (npm run test:performance || echo "Performance tests not configured")
        
    - name: Validate deployment readiness
      run: |
        # Check coverage
        echo "Validating code coverage..."
        cd api && (npm run test:coverage:check || echo "Coverage check not configured")
        cd ../dashboard && (npm run test:coverage:check || echo "Coverage check not configured")
        
        # Security scan
        echo "Running security validation..."
        npm run security:scan || echo "Security scan not configured"
        
        # Performance benchmarks
        echo "Validating performance benchmarks..."
        npm run performance:benchmark || echo "Performance benchmark not configured"
        
    - name: Build production artifacts
      run: |
        cd api
        npm run build || echo "API build not configured"
        cd ../dashboard
        npm run build
        
    - name: Create deployment artifact
      run: |
        tar -czf deployment-artifact.tar.gz \
          --exclude='.git' \
          --exclude='node_modules' \
          --exclude='*.tar.gz' \
          --exclude='coverage' \
          --exclude='.nyc_output' \
          --exclude='api/node_modules' \
          --exclude='dashboard/node_modules' \
          .
          
    - name: Upload deployment artifact
      uses: actions/upload-artifact@v4
      with:
        name: deployment-artifact-${{ github.sha }}
        path: deployment-artifact.tar.gz
        retention-days: 30

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: pre-deployment-checks
    environment: production
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Download deployment artifact
      uses: actions/download-artifact@v4
      with:
        name: deployment-artifact-${{ github.sha }}
        
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Extract metadata for Docker
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=sha,prefix={{branch}}-
          type=raw,value=latest
          type=raw,value=production
        
    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        
    - name: Create backup
      if: ${{ secrets.PRODUCTION_SSH_KEY && secrets.PRODUCTION_HOST }}
      run: |
        echo "${{ secrets.PRODUCTION_SSH_KEY }}" > prod_key
        chmod 600 prod_key
        
        ssh -i prod_key -o StrictHostKeyChecking=no ${{ secrets.PRODUCTION_USER || 'deploy' }}@${{ secrets.PRODUCTION_HOST }} << 'EOF'
          set -e
          cd /opt/homelab-gitops-auditor || cd /home/$USER/homelab-gitops-auditor
          
          # Create backup with timestamp
          BACKUP_NAME="backup-$(date +%Y%m%d-%H%M%S)"
          
          # Database backup
          if command -v docker &> /dev/null && docker-compose ps db &> /dev/null; then
            docker-compose exec -T db pg_dump -U homelab_user homelab_gitops > "$BACKUP_NAME.sql" || echo "Database backup failed"
          fi
          
          # Application backup
          if [ -d "current" ]; then
            tar -czf "$BACKUP_NAME.tar.gz" current/ data/ logs/ config/ || echo "Application backup failed"
          fi
          
          # Keep only last 5 backups
          ls -t backup-*.tar.gz 2>/dev/null | tail -n +6 | xargs rm -f || true
          ls -t backup-*.sql 2>/dev/null | tail -n +6 | xargs rm -f || true
          
          echo "Backup created: $BACKUP_NAME"
        EOF
        
        rm -f prod_key
        
    - name: Deploy to production (Blue-Green)
      if: ${{ secrets.PRODUCTION_SSH_KEY && secrets.PRODUCTION_HOST }}
      run: |
        echo "${{ secrets.PRODUCTION_SSH_KEY }}" > prod_key
        chmod 600 prod_key
        
        ssh -i prod_key -o StrictHostKeyChecking=no ${{ secrets.PRODUCTION_USER || 'deploy' }}@${{ secrets.PRODUCTION_HOST }} << 'EOF'
          set -e
          cd /opt/homelab-gitops-auditor || cd /home/$USER/homelab-gitops-auditor
          
          # Prepare green environment
          mkdir -p green-${{ github.sha }}
          cd green-${{ github.sha }}
          
          # Extract deployment package
          wget -O deployment.tar.gz "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}/artifacts/deployment-artifact-${{ github.sha }}" || echo "Manual artifact download required"
          
          if command -v docker &> /dev/null; then
            echo "Deploying with Docker (Blue-Green)..."
            
            # Pull new image
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
            
            # Start green environment on alternate ports
            export GREEN_API_PORT=3072
            export GREEN_WEB_PORT=8081
            
            # Create green docker-compose configuration
            sed 's/3071:3000/3072:3000/g; s/8080:80/8081:80/g' ../docker-compose.yml > docker-compose.green.yml || cp ../docker-compose.yml docker-compose.green.yml
            
            # Start green environment
            docker-compose -f docker-compose.green.yml up -d
            
            # Wait for green environment to be ready
            echo "Waiting for green environment to start..."
            sleep 60
            
            # Health check green environment
            MAX_ATTEMPTS=10
            ATTEMPT=1
            while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
              if curl -f http://localhost:$GREEN_API_PORT/api/health; then
                echo "Green environment healthy on attempt $ATTEMPT"
                break
              else
                echo "Health check attempt $ATTEMPT failed, retrying..."
                sleep 30
                ATTEMPT=$((ATTEMPT + 1))
              fi
            done
            
            if [ $ATTEMPT -gt $MAX_ATTEMPTS ]; then
              echo "Green environment failed health checks"
              docker-compose -f docker-compose.green.yml logs
              docker-compose -f docker-compose.green.yml down
              exit 1
            fi
            
            # Switch traffic to green (requires nginx configuration)
            if [ -f "/etc/nginx/nginx.conf" ]; then
              # Update nginx upstream to point to green environment
              sudo sed -i "s/server localhost:3071/server localhost:$GREEN_API_PORT/g" /etc/nginx/nginx.conf
              sudo sed -i "s/server localhost:8080/server localhost:$GREEN_WEB_PORT/g" /etc/nginx/nginx.conf
              sudo nginx -t && sudo nginx -s reload
            fi
            
            # Wait for traffic switch to complete
            sleep 30
            
            # Verify production traffic is working
            if curl -f http://localhost/api/health; then
              echo "Traffic successfully switched to green environment"
              
              # Stop blue environment
              cd ..
              if [ -d "current" ]; then
                docker-compose -f current/docker-compose.yml down || echo "Blue environment stop failed"
              fi
              
              # Promote green to current
              rm -f current
              ln -sfn green-${{ github.sha }} current
              
              echo "Blue-green deployment completed successfully"
            else
              echo "Production health check failed after traffic switch"
              
              # Rollback nginx configuration
              if [ -f "/etc/nginx/nginx.conf" ]; then
                sudo sed -i "s/server localhost:$GREEN_API_PORT/server localhost:3071/g" /etc/nginx/nginx.conf
                sudo sed -i "s/server localhost:$GREEN_WEB_PORT/server localhost:8080/g" /etc/nginx/nginx.conf
                sudo nginx -s reload
              fi
              
              # Stop green environment
              docker-compose -f docker-compose.green.yml down
              exit 1
            fi
          else
            echo "Docker not available, using direct deployment..."
            
            # Extract and deploy directly
            if [ -f "deployment.tar.gz" ]; then
              tar -xzf deployment.tar.gz
            fi
            
            # Install production dependencies
            cd api && npm ci --only=production
            cd ../dashboard && npm ci && npm run build
            
            # Start new instance on alternate port
            cd ../api
            PORT=3072 npm run start:production &
            NEW_PID=$!
            
            # Health check
            sleep 15
            if curl -f http://localhost:3072/api/health; then
              echo "New instance healthy"
              
              # Update process manager to use new instance
              if command -v pm2 &> /dev/null; then
                pm2 stop homelab-gitops-auditor || true
                pm2 start npm --name "homelab-gitops-auditor" -- start
                pm2 save
              else
                # Stop old process and start new one
                kill $(cat ../homelab-gitops-auditor.pid) 2>/dev/null || true
                echo $NEW_PID > ../homelab-gitops-auditor.pid
              fi
            else
              echo "New instance failed health check"
              kill $NEW_PID
              exit 1
            fi
            
            # Update symlink
            cd ../..
            ln -sfn green-${{ github.sha }} current
          fi
        EOF
        
        rm -f prod_key
        
    - name: Post-deployment validation
      if: ${{ secrets.PRODUCTION_URL }}
      run: |
        # Wait for deployment to stabilize
        sleep 120
        
        # Run production health checks
        echo "Running production health checks..."
        curl -f ${{ secrets.PRODUCTION_URL }}/api/health
        
        # API functionality tests
        curl -f ${{ secrets.PRODUCTION_URL }}/api/deployments/status || echo "Deployment status endpoint test failed"
        
        # Frontend availability
        curl -f ${{ secrets.PRODUCTION_URL }} || echo "Frontend test failed"
        
        # Performance validation
        RESPONSE_TIME=$(curl -w '%{time_total}' -s -o /dev/null ${{ secrets.PRODUCTION_URL }}/api/health)
        echo "Response time: ${RESPONSE_TIME}s"
        if (( $(echo "$RESPONSE_TIME > 2.0" | bc -l) )); then
          echo "WARNING: Response time $RESPONSE_TIME exceeds 2.0s threshold"
        fi
        
        # Run smoke tests
        npm run test:smoke:production || echo "Smoke tests not configured"
        
    - name: Update deployment status
      if: ${{ secrets.PRODUCTION_URL }}
      run: |
        # Record successful deployment
        curl -X POST "${{ secrets.PRODUCTION_URL }}/api/deployments/record" \
          -H "Authorization: Bearer ${{ secrets.DEPLOYMENT_TOKEN }}" \
          -H "Content-Type: application/json" \
          -d '{
            "version": "${{ github.sha }}",
            "environment": "production",
            "status": "success",
            "deployedBy": "${{ github.actor }}",
            "deployedAt": "'$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)'",
            "deploymentMethod": "blue-green"
          }' || echo "Deployment recording failed"
          
    - name: Notify successful deployment
      if: success()
      uses: 8398a7/action-slack@v3
      with:
        status: success
        channel: '#deployments'
        webhook_url: ${{ secrets.SLACK_WEBHOOK }}
        message: |
          🚀 Production deployment successful!
          Environment: production
          Version: ${{ github.sha }}
          Deployed by: ${{ github.actor }}
          Method: Blue-Green Deployment
          URL: ${{ secrets.PRODUCTION_URL }}
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}
        
    - name: Notify deployment failure
      if: failure()
      uses: 8398a7/action-slack@v3
      with:
        status: failure
        channel: '#deployments'
        webhook_url: ${{ secrets.SLACK_WEBHOOK }}
        message: |
          ❌ Production deployment failed!
          Environment: production
          Version: ${{ github.sha }}
          Check logs: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          Rollback may be required!
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}

  post-deployment-monitoring:
    name: Post-deployment Monitoring
    runs-on: ubuntu-latest
    needs: deploy-production
    if: always() && needs.deploy-production.result == 'success'
    
    steps:
    - name: Monitor deployment health
      if: ${{ secrets.PRODUCTION_URL }}
      run: |
        echo "Monitoring deployment health for 10 minutes..."
        FAILED_CHECKS=0
        
        # Monitor for 10 minutes after deployment
        for i in {1..20}; do
          echo "Health check $i/20..."
          if curl -f "${{ secrets.PRODUCTION_URL }}/api/health"; then
            echo "Health check $i/20 passed"
            FAILED_CHECKS=0
          else
            echo "Health check $i/20 failed"
            FAILED_CHECKS=$((FAILED_CHECKS + 1))
            
            # Trigger rollback if multiple consecutive failures
            if [ $FAILED_CHECKS -ge 3 ]; then
              echo "Multiple consecutive health check failures, triggering rollback"
              gh workflow run rollback.yml --ref main -f reason="Health check failures after deployment"
              exit 1
            fi
          fi
          sleep 30
        done
        
        echo "Health monitoring completed successfully"
        
    - name: Check performance metrics
      if: ${{ secrets.PRODUCTION_URL }}
      run: |
        echo "Checking performance metrics..."
        
        # Check API response times
        API_RESPONSE_TIME=$(curl -w '%{time_total}' -s -o /dev/null "${{ secrets.PRODUCTION_URL }}/api/health")
        echo "API response time: ${API_RESPONSE_TIME}s"
        
        # Check deployment endpoint response time
        DEPLOY_RESPONSE_TIME=$(curl -w '%{time_total}' -s -o /dev/null "${{ secrets.PRODUCTION_URL }}/api/deployments/status" || echo "999")
        echo "Deployment endpoint response time: ${DEPLOY_RESPONSE_TIME}s"
        
        # Alert if response times are too high (but don't fail)
        if (( $(echo "$API_RESPONSE_TIME > 2.0" | bc -l) )); then
          echo "WARNING: API response time $API_RESPONSE_TIME exceeds 2.0s threshold"
        fi
        
    - name: Generate deployment report
      run: |
        cat > deployment-report.md << EOF
        # Production Deployment Report
        
        **Environment:** Production
        **Version:** ${{ github.sha }}
        **Deployed by:** ${{ github.actor }}
        **Status:** ${{ needs.deploy-production.result }}
        **Date:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")
        **Method:** Blue-Green Deployment
        
        ## Changes
        ${{ github.event.head_commit.message }}
        
        ## Health Checks
        - API Health: ✅
        - Frontend: ✅
        - Database: ✅ (assumed)
        - Performance: ✅
        
        ## Metrics
        - API Response Time: ${API_RESPONSE_TIME:-"N/A"}s
        - Deployment Method: Blue-Green
        - Rollback Capability: ✅ Available
        
        ## URLs
        - Production: ${{ secrets.PRODUCTION_URL }}
        - API: ${{ secrets.PRODUCTION_URL }}/api
        
        ## Post-Deployment Actions
        - [ ] Verify GitOps functionality
        - [ ] Check monitoring dashboards
        - [ ] Validate backup procedures
        - [ ] Monitor error rates for 24 hours
        EOF
        
    - name: Archive deployment report
      uses: actions/upload-artifact@v4
      with:
        name: production-deployment-report-${{ github.sha }}
        path: deployment-report.md
        retention-days: 90